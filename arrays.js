// 100
// Вы получаете массив чисел, возвращаете сумму всех положительных чисел.
// Пример [1,-4,7,12]=>1 + 7 + 12 = 20
// Примечание: если суммировать нечего, по умолчанию используется сумма 0.

function sumPositive(arr) {
    return arr.filter(e => e > 0).reduce((x, i) => x + i, 0);
  }
  console.log(sumPositive([1,-4,7,12]));
  
  
  
  //101
  // Простой, учитывая строку слов, возвращает длину самого короткого слова (слов).
  // Строка никогда не будет пустой, и вам не нужно учитывать разные типы данных.
  
  function shortestWord(s) {
    return s.split(' ').map((e) => e.length).sort((a, b) => a - b).shift();
  }
  console.log(shortestWord('bitcoin take over the world maybe who knows perhaps'));
  
  
  
  //102
  // В этом ката вы создадите функцию, которая принимает список неотрицательных целых чисел 
  // и строк и возвращает новый список с отфильтрованными строками.
  // пример
  // filter_list([1,2,'a','b']) == [1,2]
  // filter_list([1,'a','b',0,15]) == [1,0,15]
  // filter_list([1,2,'aasf','1','123',123]) == [1,2,123]
  
  function listFiltering(l) {
    return l.filter(e => e >= 0 && typeof e === 'number');
  }
  console.log(listFiltering([1, 2,'aasf','1','123', 123, -1]));
  
  

  //103
  // Добро пожаловать. В этом ката вас просят возвести в квадрат каждую цифру числа и соединить их.
  // Например, если мы запустим 9119 через функцию, выйдет 811181, потому что 9**2 равно 81, а 1**2 равно 1.
  // Примечание: функция принимает целое число и возвращает целое число.
  
  function squareDigit(num) {
    return Number.parseInt(num.toString().split('').map(e => parseInt(e) ** 2).join(''));
  }
  console.log(squareDigit(9119));
  
  

  //(104)
  // Я дам вам целое число. Верни мне фигуру такой же длины и ширины, как целое число. 
  // Целое число будет целым числом от 1 до 50.
  // пример
  // n = 3, поэтому я ожидаю, что будет квадрат 3x3, как показано ниже, в виде строки:
  // +++
  // +++
  // +++
  
  function generateShape(int){
    return Array(int).fill().map(e => '+'.repeat(int)).join('\n');
    }
  console.log(generateShape(3));
  
  
  
  //105
  // Создайте программу, которая фильтрует список строк и возвращает список только 
  // с именами ваших друзей.
  // Если в имени ровно 4 буквы, можете быть уверены, что это должен быть ваш друг!
  //  В противном случае можете быть уверены, что он не ...
  // Пример: Input = ["Ryan", "Kieran", "Jason", "Yous"], Output = ["Ryan", "Yous"].
  // т.е.
  // friend ["Ryan", "Kieran", "Mark"] `shouldBe` ["Ryan", "Mark"]
  // Примечание: сохраняйте исходный порядок имен в выводе.
  
  function friend(friends) {
    return friends.filter(e => e.length === 4);
  }
  console.log(friend(["Ryan", "Kieran", "Jason", "Yous"]));
  
  
  
  //[106]
  // Возвращает количество (количество) гласных в заданной строке.
  // Мы будем считать (a, e, i, o, u) это гласными (но не y).
  // Входная строка будет состоять только из строчных букв и / или пробелов.
  
  function getCount(str) {
     return Array.from(str).filter(e => 'aeiou'.includes(e)).length;
  }
  console.log(getCount('abracadabra'));
  
  
  
  //107
  // У некоторых чисел есть забавные свойства. Например:
  // 89 -> 8¹ + 9² = 89 * 1
  // 695 -> 6² + 9³ + 5⁴ = 1390 = 695 * 2
  // 46288 -> 4³ + 6⁴ + 2⁵ + 8⁶ + 8⁷ = 2360688 = 46288 * 51
  // Учитывая положительное целое число n, записанное как abcd ... (a, b, c, d ... - цифры) 
  // и положительное целое число p
  // мы хотим найти положительное целое число k, если оно существует, например, сумма цифр n,
  //  взятых в последовательные степени p, равна k * n.
  // Другими словами:
  // Существует ли целое число k, например: (a ^ p + b ^ (p + 1) + c ^ (p + 2) + d ^ (p + 3) + ...) = n * k
  // Если это так, мы вернем k, если не вернем -1.
  // Примечание : n и p всегда будут строго положительными целыми числами.
  // digPow(89, 1) should return 1 since 8¹ + 9² = 89 = 89 * 1
  // digPow(92, 1) should return -1 since there is no k such as 9¹ + 2² equals 92 * k
  // digPow(695, 2) should return 2 since 6² + 9³ + 5⁴= 1390 = 695 * 2
  // digPow(46288, 3) should return 51 since 4³ + 6⁴+ 2⁵ + 8⁶ + 8⁷ = 2360688 = 46288 * 51
  
  function digPow(n, p) {
    let num = n.toString().split('').map(e => parseInt(e) ** p++).reduce((a, b) => a + b, 0);
    return Number.isInteger(num / n) ? num / n : - 1;
  }
  console.log(digPow(92, 1));
  
  
  
  // 108
  // Ваша цель в этом ката - реализовать функцию различия, которая вычитает один список из другого
  // и возвращает результат.
  // Он должен удалить все значения из списка a, которые присутствуют в списке b.
  // arrayDiff([1,2],[1]) == [2]
  // Если значение присутствует в b, все его вхождения должны быть удалены из другого:
  // arrayDiff([1,2,2,2,3],[2]) == [1,3]
  
  function arrayDiff(a, b) {
    return a.filter(e => !b.includes(e));
  }
  console.log(arrayDiff([1, 2, 2, 2, 3], [2]));
  
  
  
  //109
  // Напишите функцию, которая принимает в качестве аргумента одну строку (word). 
  // Функция должна возвращать упорядоченный список, содержащий индексы всех 
  // заглавных букв в строке.
  // пример
  // Test.assertSimilar( capitals('CodEWaRs'), [0,3,4,6] );
  
  function capitals(word) {
    return word.split('').map((e, i) => e.toUpperCase() === e ? i : null).filter(x => x != null);
  }
  console.log(capitals('CodEWaRs'));
  
  
  
  //(110)
  // Напишите функцию insertDash(num)/, InsertDash(int num)которая будет вставлять тире ('-') 
  // между каждыми двумя нечетными числами в num. Например: если число 454793, 
  // вывод должен быть 4547-9-3. Не считайте ноль как нечетное число.
  // Обратите внимание, что число всегда будет неотрицательным (> = 0).
  
  function insertDash(num) {
    //return num.toString().replace(/[13579](?=[13579])/g, "$&-");
  return num.toString().split('').reduce((a, b) => a[a.length-1] % 2 && b % 2 ? a + '-' + b : a + b);
  }
  console.log(insertDash(454793));
  
  
  
  //[111]
  // Учитывая массив (arr) в качестве аргумента, завершите функцию, countSmileys которая 
  // должна вернуть общее количество улыбающихся лиц.
  // Правила улыбающегося лица:
  // Каждый смайлик должен содержать допустимую пару глаз. Глаза можно пометить как : или ;
  // У смайлика может быть нос, но это не обязательно. Допустимые символы для носа - или ~
  // Каждое улыбающееся лицо должно иметь улыбающийся рот , который должен быть отмечен либо ) или D
  // Не допускается использование дополнительных символов, кроме упомянутых.
  // Примеры действительных смайлов: :) :D ;-D :~)
  // Недействительные смайлы: ;( :> :} :]
  // пример
  // countSmileys([':)', ';(', ';}', ':-D']);       // should return 2;
  // countSmileys([';D', ':-(', ':-)', ';~)']);     // should return 3;
  // countSmileys([';]', ':[', ';*', ':$', ';-D']); // should return 1;
  
  function countSmileys(arr) {
    let smileys = [":)",";)",":-)",";-)",";~)",":~)",":D",";D",":-D",":~D",";-D",";~D"];
    return arr.filter(e => smileys.includes(e)).length;
    //return arr.filter(e => e.match(/^[:;][-~]?[)D]$/)).length;
  }
  console.log(countSmileys([':)', ';(', ';}', ':-D']));
  
  
  
  // (112)
  // Вызов:
  // Учитывая двумерный массив, верните новый массив, который переносит только те массивы из оригинала, 
  // которые не были пустыми и все элементы которых относятся к одному типу (то есть однородны). Для 
  // простоты массивы внутри массива будут содержать только символы и целые числа.
  // Пример:
  // Учитывая [[1, 5, 4], ['a', 3, 5], ['b'], [], ['1', 2, 3]], ваша функция должна вернуть [[1, 5, 4], ['b']].
  // Дополнение:
  // Имейте в виду, что для этого ката мы предполагаем, что пустые массивы не являются однородными.
  // Результирующие массивы должны быть в том порядке, в котором они были изначально, и не должны изменять свои значения.
  // Неявное приведение типов не допускается. Подмассив [1, '2'] будет считаться недопустимым и должен быть отфильтрован.
  
  function arrHomogenous(arrays) {
    return arrays.filter(e => e.length !== 0 && e.every(x => typeof x === typeof e[0]));
  }
  console.log(arrHomogenous([[1, 5, 4], ['a', 3, 5], ['b'], [], ['1', 2, 3]]));
  
  
  
  //(113)
  // Время выиграть в лотерею!
  // Учитывая лотерейный билет (билет), представленный массивом из двух значений, вы должны выяснить, 
  // выиграли ли вы джекпот. Пример билета:
  // [ [ 'ABC', 65 ], [ 'HGR', 74 ], [ 'BYHT', 74 ] ]
  // Для этого вы должны сначала подсчитать «мини-выигрыши» на своем билете. В каждом подмассиве есть 
  // как строка, так и число. Если код любого из символов в строке совпадает с номером, вы получаете 
  // мини-выигрыш. Обратите внимание, у вас может быть только одна мини-победа на каждый подмассив.
  // После того, как вы подсчитали все свои мини-выигрыши, сравните это число с другим введенным значением 
  // (выигрыш). Если ваша сумма больше или равна (выигрыш), верните «Победитель!». Иначе верните «Неудачник!».
  // Все входные данные будут в правильном формате. Строки на билетах не всегда одинаковой длины.
  
  function bingo(ticket, win) {
    return ticket.filter(e => e[0].split('').some(x => x.charCodeAt(0) == e[1])).length >= win ? 'Winner!' : 'Loser!';
  }
  console.log(bingo([['ABC', 65 ], ['HGR', 74], ['BYHT', 74]], 1));
  
  
  
  //114
  // Сценарий
  // Несколько человек стоят в ряд, разделенные на две команды . Первый человек входит в команду 1, 
  // второй идет в команду 2 , третий переходит в команду 1 , и так далее.
  // Задача
  // Учитывая массив положительных целых чисел (веса людей) , верните новый массив / кортеж из двух 
  // целых чисел , где первое - это общий вес команды 1 , а второе - общий вес команды 2 .
  // Примечания
  // Размер массива составляет по меньшей мере 1 .
  // Все числа будут положительными .
  // Примеры ввода >> вывода
  // rowWeights([13, 27, 49])  ==>  return (62, 27)
  // Пояснение :
  // Первый элемент 62 - это общий вес команды 1 , а второй элемент 27 - это общий вес команды 2 .
  // rowWeights([50, 60, 70, 80])  ==>  return (120, 140)
  // Пояснение :
  // Первый элемент 120 - это общий вес команды 1 , а второй элемент 140 - это общий вес команды 2 .
  // rowWeights([80])  ==>  return (80, 0)
  // Пояснение :
  // Первый элемент 80 - это общий вес команды 1 , а второй элемент 0 - это общий вес команды 2 .
  
  function rowWeights(array){
    let even = array.filter((_, i) => i % 2 === 0).reduce((a, b) => a+b, 0);
    let odd = array.filter((_, i) => i % 2 === 1).reduce((a, b) => a+b, 0);
    return [even, odd];
    //return array.reduce((a,b,i)=>(a[i%2]+=b,a),[0,0])
  }
  console.log(rowWeights([29]));
  
  
  
  //(115)
  //Ваша задача - завершить функцию, которая принимает строку и возвращает массив со всеми возможными поворотами данной строки в верхнем регистре.
  //Должен вернуться:
  // [ "CODEWARS",
  //   "ODEWARSC",
  //   "DEWARSCO",
  //   "EWARSCOD",
  //   "WARSCODE",
  //   "ARSCODEW"
  //   "RSCODEWA",
  //   "SCODEWAR" ]
  
  function scrollingText(text){
    return Array(text.length).fill(text).map((e, i) => (e.slice(i) + e.slice(0, i)).toUpperCase());
  }
  console.log(scrollingText("abc"));